/*
* Copyright 2021 Comcast Cable Communications Management, LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* SPDX-License-Identifier: Apache-2.0
*/

// Simple "cover" / abstraction for accessing the Firebolt Open RPC metadata
// Dependent upon the schema of the firebolt-xxx-sdk.json files generated by "npm run build:openrpc" 

'use strict';

import { readFile } from 'fs/promises';
import * as path from 'path';
import * as fs from 'fs';
import * as https from 'https';

import Ajv from 'ajv';
const ajv = new Ajv();

import { createTmpFile,createCaseAgnosticMethod } from './util.mjs';
import { config } from './config.mjs';
import { logger } from './logger.mjs';
import { dereferenceMeta } from './fireboltOpenRpcDereferencing.mjs';
import { isSdkEnabled } from './sdkManagement.mjs';

// Build a method map for a single SDK (given by an object read from firebolt-xxx-sdk.json file)
function buildMethodMap(sdkOpenrpc) {
  if ( ! sdkOpenrpc || ! isObject(sdkOpenrpc) ) { return {}; }
  if ( ! sdkOpenrpc ) { return undefined; }
  if ( ! sdkOpenrpc.methods ) { return undefined; }

  var result = sdkOpenrpc.methods.reduce(function(map, obj) {
    //coverting module names to lowerCase
    if(config.app.caseInsensitiveModules){
      obj.name = createCaseAgnosticMethod(obj.name);
    }
    map[obj.name] = obj;
    return map;
  }, {});

  return result;
}

function getRawMeta() {
  return rawMeta;
}

function getMeta() {
  return meta;
}

function getMethod(methodName) {
  for ( let ii = 0; ii < config.dotConfig.supportedOpenRPCs.length; ii += 1 ) {
    const sdkName = config.dotConfig.supportedOpenRPCs[ii].name;
    if (config.app.caseInsensitiveModules){
      methodName = createCaseAgnosticMethod(methodName);
    }
    if ( methodMaps[sdkName] ) {
      if ( methodName in methodMaps[sdkName] ) { return methodMaps[sdkName][methodName]; }
    }
  }
  return undefined;
}

function isMethodKnown(methodName) {
  // Returns true in "novalidate mode"
  if( ! config.validate.includes("method") ){
    return true;
  }
  const oMethod = getMethod(methodName);
  return ( oMethod ? true : false );
}

function getSchema(schemaName) {
  for ( const ii = 0; ii < config.dotConfig.supportedOpenRPCs.length; ii += 1 ) {
    const sdkName = config.dotConfig.supportedOpenRPCs[ii].name;
    if ( schemaName in meta[sdkName].components.schemas ) { return meta[sdkName].components.schemas[schemaName]; }
  }
  return undefined;
}

function getFirstExampleValueForMethod(methodName) {
  const oMethod = getMethod(methodName);
  if ( ! oMethod ) { return undefined; }
  if ( ! oMethod.examples ) { return undefined; }
  if ( oMethod.examples.length <= 0 ) { return undefined; }
  if ( ! oMethod.examples[0].result ) { return undefined; }
  return oMethod.examples[0].result.value;
}

// Returns undefined if/when no notes or an object like { alternative: "xxx", notes: "xxx", docUrl: "xxx" }
function getDeveloperNotesForMethod(methodName) {
  const oMethod = getMethod(methodName);
  if ( ! oMethod ) { return undefined; }
  if ( ! oMethod.tags ) { return undefined; }
  if ( oMethod.tags.length <= 0 ) { return undefined; }
  const developerNotesTagName = config.app.developerNotesTagName;
  const developerNotesTag = oMethod.tags.find(oTag => oTag.name.toLowerCase() === developerNotesTagName.toLowerCase());
  if ( ! developerNotesTag ) { return undefined; }
  const developerNotes = {
    notes       : developerNotesTag['x-notes'],
    docUrl      : developerNotesTag['x-doc-url']
  };
  return developerNotes;
}

// Are the given params valid for thegiven method, based on the OpenRPC metadata?
// Returns an array of errors; Returns an empty array if no errors are found
function validateMethodCall(methodName, params) {
  // Returns an empty array in "novalidate mode"
  if( ! config.validate.includes("params") ){
    return [];
  }
  let errors = [];

  try {
    const oMethod = getMethod(methodName);
    const oParams = oMethod.params;
    for ( let pp = 0; pp < oParams.length; pp += 1 ) {
      let oParam = oParams[pp];
      let paramName = oParam.name;
      let oSchema = oParam.schema;
      if ( '$ref' in oSchema  ) {
        const ref = oSchema['$ref'];
        const schemaName = ref.substring(ref.lastIndexOf('/') + 1);
        oSchema = getSchema(schemaName);
      }

      if ( oParam.required || ( params && params[paramName] ) ) {
        const validate = ajv.compile(oSchema);
        const valid = validate(params[paramName]);
        if ( !valid ) {
          errors.push(...validate.errors);
        }
      }
    }

    return errors || [];
  } catch ( ex ) {
    logger.error('ERROR: Could not validate method call:');
    logger.error('Method:');
    logger.error(methodName);
    logger.error('Params:');
    logger.error(params);
    logger.error('Exception:');
    logger.error(ex);
    errors.push(`ERROR: Could not validate call to method ${methodName} with params ${JSON.stringify(params)}`);

    return errors; // Treat as invalid
  }
}

// Is the given value a valid result for the given method, based on the OpenRPC metadata?
// Returns an array of errors; Returns an empty array if no errors are found
function validateMethodResult(val, methodName) {
  // Returns an empty array in "novalidate mode"
  if( ! config.validate.includes("response") ){
    return [];
  }
  let errors = [];

  // Short-circuit validation for result values specified as functions
  if ( typeof val === 'string' && val.trimStart().startsWith('function') ) { return errors; }

  try {
    const oMethod = getMethod(methodName);
    const oResult = oMethod.result;
    let oSchema = oResult.schema;
    if ( '$ref' in oSchema  ) {
      const ref = oSchema['$ref'];
      const schemaName = ref.substring(ref.lastIndexOf('/') + 1);
      oSchema = getSchema(schemaName);
    }

    const validate = ajv.compile(oSchema);
    const valid = validate(val);
    if ( !valid ) {
      errors = validate.errors;
    }

    return errors || [];
  } catch ( ex ) {
    logger.error('ERROR: Could not validate value:');
    logger.error('Value:');
    logger.error(val);
    logger.error('Method:');
    logger.error(methodName);
    logger.error('Exception:');
    logger.error(ex);
    errors.push(`ERROR: Could not validate value ${val} for method ${methodName}`);

    return errors; // Treat as invalid
  }
}

function isObject(val) {
  var type = typeof val;
  return type === 'function' || type === 'object' && !!val;
}

// Is the given value a valid error for the given method?
// Returns an array of errors; Returns an empty array if no errors are found
function validateMethodError(val) {
  const errors = [];

  // Short-circuit validation for error values specified as functions
  if ( typeof val === 'string' && val.trimStart().startsWith('function') ) { return errors; }

  if ( !( isObject(val)) ) {
    errors.push(`ERROR: ${val} is not a valid error value: Object expected`);
    return errors;
  }
  if ( !('code' in val)) {
    errors.push(`ERROR: ${val} is not a valid error value: Mandatory 'code' property missing`);
    return errors;
  }
  if ( !('message' in val )) {
    errors.push(`ERROR: ${val} is not a valid error value: Mandatory 'message' property missing`);
    return errors; 
  }
  return errors;
}

async function downloadOpenRpcJsonFile(url) {
  const tmpObj = createTmpFile('mf-openrpc-', '.json');
  return new Promise(function(resolve, reject) {
    try {
      https.get(url, (res) => {
        const filePath = tmpObj.name;
        const outStream = fs.createWriteStream(filePath);
        res.pipe(outStream);
        outStream.on('finish',() => {
            outStream.close();
            resolve(tmpObj.name);
        });
      });
    } catch ( ex ) {
      reject(ex);
    }
  });
}

// Load the firebolt-xxx-sdk.json file for the given SDK, if that SDK is enabled
async function readSdkJsonFileIfEnabled(sdkName) {
  let url, fileUrl;
  if ( isSdkEnabled(sdkName) ) {
    try {
      const oSdk = config.dotConfig.supportedOpenRPCs.find((oSdk) => { return ( oSdk.name === sdkName ); });
      if ( oSdk.fileName ) {
        const openRpcFileName = oSdk.fileName;
        if ( path.isAbsolute(openRpcFileName) || openRpcFileName.startsWith('~') ) {
          // Absolute file path given -- read from that file path exactly as-is
          fileUrl = new URL(openRpcFileName, import.meta.url);
        } else {
          // Relative file path given -- read from file with given name from current
          // directory (build/), assuming file was copied there/here via a build step
          fileUrl = new URL(`./${openRpcFileName}`, import.meta.url);
        }
        rawMeta[sdkName] = JSON.parse(
          await readFile(fileUrl)
        );
        logger.info(`Loaded ${sdkName} SDK from ${fileUrl}`);
      } else if ( oSdk.url ) {
        url = new URL(oSdk.url);
        const fileUrl = await downloadOpenRpcJsonFile(url);
        rawMeta[sdkName] = JSON.parse(
          await readFile(fileUrl)
        );
        logger.info(`Loaded ${sdkName} SDK from URL ${url}`);
      } else {
        logger.error(`ERROR: Either 'url' or 'fileName' must be specified for SDK ${sdkName}; Skipping`);
        return;
      }
      
    } catch ( ex ) {
      logger.error(`ERROR: Could not load ${sdkName} SDK from ${url}`);
      console.log(ex);
    }
  }
}

// Load the OpenRPC files for any/all SDKs that are enabled
// NOTE: Assumes the build process has put the firebolt-xxx-sdk.json files in the same directory
//       as the source code from the src/ directory
async function readAllEnabledSdkJsonFiles() {
  if (isSdkEnabled('mock')) {
    await readSdkJsonFileIfEnabled('mock');
  }
  else {
    await Promise.all(config.dotConfig.supportedOpenRPCs.map(async (oSdk) => {
      const sdkName = oSdk.name;
      await readSdkJsonFileIfEnabled(sdkName);
    }));
  }
}

function buildMethodMapsForAllEnabledSdks() {
  // Build faster-performing maps for methods (vs. openrpc.methods array)
  config.dotConfig.supportedOpenRPCs.forEach(function(oSdk) {
    const sdkName = oSdk.name;
    if ( isSdkEnabled(sdkName) ) {
      methodMaps[sdkName] = buildMethodMap(meta[sdkName]);
    }
  });
}

// --- Module-level Code ---

// Will contain one key for each API enabled (See .mf.config.json::supportedOpenRPCs)
// The value for each key will be an object containing keys: openrpc, info, methods, and components (contents of firebolt-xxx-sdk.json file)
const rawMeta = {};

// Same as above, but $refs have been dereferenced; this is the main datastructure used here
let meta = {};

// Will contain one key for each API enabled (See .mf.config.json::supportedOpenRPCs)
// The value for each key will be an object with keys for each method
const methodMaps = {};

// Load OpenRPC definitions for all enabled SDKs, then build method maps for each
readAllEnabledSdkJsonFiles()
.then(() => meta = dereferenceMeta(rawMeta))
.then(buildMethodMapsForAllEnabledSdks);



// --- Exports ---
export const testExports={
  rawMeta, meta, methodMaps, buildMethodMapsForAllEnabledSdks, buildMethodMap, downloadOpenRpcJsonFile
}
export {
  getRawMeta, getMeta,
  getMethod, isMethodKnown, getSchema,
  getFirstExampleValueForMethod, getDeveloperNotesForMethod,
  validateMethodCall, validateMethodResult, validateMethodError
};