/*
* Copyright 2021 Comcast Cable Communications Management, LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* SPDX-License-Identifier: Apache-2.0
*/

// Simple "cover" / abstraction for accessing the Firebolt Open RPC metadata
// Dependent upon the schema of the firebolt-xxx-sdk.json files generated by "npm run build:openrpc" 

'use strict';

import { readFile } from 'fs/promises';

import Ajv from 'ajv';
const ajv = new Ajv();

import { config } from './config.mjs';
import { dereferenceMeta } from './fireboltOpenRpcDereferencing.mjs';
import { isSdkEnabled } from './sdkManagement.mjs';

// Build a method map for a single SDK (given by an object read from firebolt-xxx-sdk.json file)
function buildMethodMap(sdkOpenrpc) {
  if ( ! sdkOpenrpc || ! isObject(sdkOpenrpc) ) { return {}; }
  if ( ! sdkOpenrpc ) { return undefined; }
  if ( ! sdkOpenrpc.methods ) { return undefined; }

  var result = sdkOpenrpc.methods.reduce(function(map, obj) {
    map[obj.name] = obj;
    return map;
  }, {});

  return result;
}

function getMeta() {
  return meta;
}

function getDereferencedMeta() {
  return dereferenceMeta(meta);
}

function getMethod(methodName) {
  for ( let ii = 0; ii < config.app.supportedSdks.length; ii += 1 ) {
    const sdkName = config.app.supportedSdks[ii];
    if ( methodName in methodMaps[sdkName] ) { return methodMaps[sdkName][methodName]; }
  }
  return undefined;
}

function isMethodKnown(methodName) {
  const oMethod = getMethod(methodName);
  return ( oMethod ? true : false );
}

function getSchema(schemaName) {
  for ( const ii = 0; ii < config.app.supportedSdks.length; ii += 1 ) {
    const sdkName = config.app.supportedSdks[ii];
    if ( schemaName in meta[sdkName].components.schemas ) { return meta[sdkName].components.schemas[schemaName]; }
  }
  return undefined;
}

function getFirstExampleValueForMethod(methodName) {
  const oMethod = getMethod(methodName);
  if ( ! oMethod ) { return undefined; }
  if ( ! oMethod.examples ) { return undefined; }
  if ( oMethod.examples.length <= 0 ) { return undefined; }
  if ( ! oMethod.examples[0].result ) { return undefined; }
  return oMethod.examples[0].result.value;
}

// Are the given params valid for thegiven method, based on the OpenRPC metadata?
// Returns an array of errors; Returns an empty array if no errors are found
function validateMethodCall(methodName, params) {
  let errors = [];

  try {
    const oMethod = getMethod(methodName);
    const oParams = oMethod.params;
    for ( let pp = 0; pp < oParams.length; pp += 1 ) {
      let oParam = oParams[pp];
      let paramName = oParam.name;
      let oSchema = oParam.schema;
      if ( '$ref' in oSchema  ) {
        const ref = oSchema['$ref'];
        const schemaName = ref.substring(ref.lastIndexOf('/') + 1);
        oSchema = getSchema(schemaName);
      }

      const validate = ajv.compile(oSchema);
      const valid = validate(params[paramName]);
      if ( !valid ) {
        errors.push(validate.errors);
      }
    }

    return errors || [];
  } catch ( ex ) {
    console.log('ERROR: Could not validate method call:');
    console.log('Method:');
    console.log(methodName);
    console.log('Params:');
    console.log(params);
    console.log('Exception:');
    console.log(ex);
    errors.push(`ERROR: Could not validate call to method ${methodName} with params ${params}`);

    return errors; // Treat as invalid
  }
}

// Is the given value a valid result for the given method, based on the OpenRPC metadata?
// Returns an array of errors; Returns an empty array if no errors are found
function validateMethodResult(val, methodName) {
  let errors = [];

  // Short-circuit validation for result values specified as functions
  if ( typeof val === 'string' && val.trimStart().startsWith('function') ) { return errors; }

  try {
    const oMethod = getMethod(methodName);
    const oResult = oMethod.result;
    let oSchema = oResult.schema;
    if ( '$ref' in oSchema  ) {
      const ref = oSchema['$ref'];
      const schemaName = ref.substring(ref.lastIndexOf('/') + 1);
      oSchema = getSchema(schemaName);
    }

    const validate = ajv.compile(oSchema);
    const valid = validate(val);
    if ( !valid ) {
      errors = validate.errors;
    }

    return errors || [];
  } catch ( ex ) {
    console.log('ERROR: Could not validate value:');
    console.log('Value:');
    console.log(val);
    console.log('Method:');
    console.log(methodName);
    console.log('Exception:');
    console.log(ex);
    errors.push(`ERROR: Could not validate value ${val} for method ${methodName}`);

    return errors; // Treat as invalid
  }
}

function isObject(val) {
  var type = typeof val;
  return type === 'function' || type === 'object' && !!val;
}

// Is the given value a valid error for the given method?
// Returns an array of errors; Returns an empty array if no errors are found
function validateMethodError(val) {
  const errors = [];

  // Short-circuit validation for error values specified as functions
  if ( typeof val === 'string' && val.trimStart().startsWith('function') ) { return errors; }

  if ( ! isObject(val) ) {
    errors.push(`ERROR: ${val} is not a valid error value: Object expected`);
    return errors;
  }
  if ( ! 'code' in val ) {
    errors.push(`ERROR: ${val} is not a valid error value: Mandatory 'code' property missing`);
    return errors;
  }
  if ( ! 'message' in val ) {
    errors.push(`ERROR: ${val} is not a valid error value: Mandatory 'message' property missing`);
    return errors; 
  }
  return errors;
}

// Load the firebolt-xxx-sdk.json file for the given SDK, if that SDK is enabled
async function readSdkJsonFileIfEnabled(sdkName) {
  let url;
  if ( isSdkEnabled(sdkName) ) {
    try {
      url = new URL(`./firebolt-${sdkName}-sdk.json`, import.meta.url);
      meta[sdkName] = JSON.parse(
        await readFile(url)
      );
      console.log(`Loaded ${sdkName} SDK from ${url}`);
    } catch ( ex ) {
      console.log(`ERROR: Could not load ${sdkName} SDK from ${url}`);
    }
  }
}

// Load the firebolt-xxx-sdk.json files for any/all SDKs that are enabled ('core' always; others optionally)
// NOTE: Assumes the build process has put the firebolt-xxx-sdk.json files in the same directory
//       as the source code from the src/ directory
async function readAllEnabledSdkJsonFiles() {
  await Promise.all(config.app.supportedSdks.map(async (sdkName) => {
    await readSdkJsonFileIfEnabled(sdkName);
  }));
}

function buildMethodMapsForAllEnabledSdks() {
  // Build faster-performing maps for methods (vs. openrpc.methods array)
  config.app.supportedSdks.forEach(function(sdkName) {
    if ( isSdkEnabled(sdkName) ) {
      methodMaps[sdkName] = buildMethodMap(meta[sdkName]);
    }
  });
}

// --- Module-level Code ---

// Will contain one key for each API enabled (See config.app.supportedSdks; core is always enabled; others are optional)
// The value for each key will be an object containing keys: openrpc, info, methods, and components (contents of firebolt-xxx-sdk.json file)
const meta = {};

// Will contain one key for each API enabled (See config.app.supportedSdks; core is always enabled; others are optional)
// The value for each key will be an object with keys for each method
const methodMaps = {};

// Load OpenRPC definitions for all enabled SDKs, then build method maps for each
readAllEnabledSdkJsonFiles()
.then(buildMethodMapsForAllEnabledSdks);

// --- Exports ---

export {
  getMeta, getDereferencedMeta,
  getMethod, isMethodKnown, getSchema,
  getFirstExampleValueForMethod,
  validateMethodCall, validateMethodResult, validateMethodError
};
